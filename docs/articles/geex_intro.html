<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Estimating Equations in R: <code>geex</code> • geex</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">geex</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Estimating Equations in R: <code>geex</code>
</h1>
                        <h4 class="author">B. Saul</h4>
            
            <h4 class="date">2017-06-14</h4>
          </div>

    
    
<div class="contents">
<p>M-estimation theory provides a framework for asympotic properties of estimators that are solutions to estimating equations. Regression methods such as Generalized Linear Models (GLM) and Generalized Estimating Equations (GEE) fit in this framework. Countless R packages implement specific applications of estimating equations. A common reason to use M-estimation is to compute the empirical sandwich variance estimator - an asymptotically Normal and “robust” covariance. Many packages compute this variance estimator automatically, and packages such as <code>sandwich</code> take the output of other modeling methods to compute this variance estimate.</p>
<p><code>geex</code> aims to be provide a more general framework that any modelling method can use to compute point and variance estimates for parameters that are solutions to estimating equations. The basic idea:</p>
<ul>
<li>Analyst provides three things: (1) data, (2) instructions on how to split the data into independent units and (3) a function that takes unit-level data and returns a function in terms of parameters.</li>
<li>
<code>geex</code> computes point estimates and variance estimates for the parameters.</li>
</ul>
<div id="basic-setup" class="section level2">
<h2 class="hasAnchor">
<a href="#basic-setup" class="anchor"></a>Basic Setup</h2>
<p>I mostly follow the notation of Stefanski and Boos. I tried to keep notation in the code similar to mathematical notation.</p>
<p>Suppose we have <span class="math inline">\(m\)</span> independent or nearly independent units of observations.</p>
<p><span class="math display">\[
\sum_{i = 1}^m \psi(O_i, \theta) = 0
\]</span></p>
<p>Where <span class="math inline">\(\psi\)</span> is vector of length <span class="math inline">\(p\)</span> corresponding to the number of parameters in <span class="math inline">\(\theta\)</span>.</p>
<p>For notational ease, let <span class="math inline">\(\psi(O_i, \theta) = \psi_i\)</span> Let: <span class="math display">\[
A_i = - \frac{\partial \psi(O_i, \theta)}{\partial \theta}
\]</span></p>
<p><span class="math display">\[
A = \sum_{i = 1}^m A_i
\]</span></p>
<p><span class="math display">\[
B_i = \psi_i \psi_i^T
\]</span></p>
<p><span class="math display">\[
B = \sum_{i = 1}^m B_i
\]</span></p>
<p><span class="math display">\[
\Sigma = A^{-1} B \{A^{-1}\}^T
\]</span></p>
</div>
<div id="stefanski-boos-example-1" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-1" class="anchor"></a>Stefanski &amp; Boos example 1</h2>
<p>Example 1 illustrates calculation of sample mean and variance using estimating equations. I generate a data set with 100 observations drawn from a Normal(5, 2) distribution. Table  translates the estimating equations into the <code>R</code> function needed for <code>geex</code>:</p>

<p>With the <code>eeFUN</code> function prepared, it is passed to <code>estimate_equations</code> along with the data, a character string naming the variable that identifies groups within the dataset, and starting values for the root finder.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB1_eefun, 
                                <span class="dt">data  =</span> dt,
                                <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</code></pre></div>

</div>
<div id="stefanski-boos-example-2" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-2" class="anchor"></a>Stefanski &amp; Boos example 2</h2>
<p>Example 2 illustrates calculation of a ratio estimator. I generate a data set with 100 observations where <span class="math inline">\(Y \sim N\)</span>(5, 2) and <span class="math inline">\(X \sim N\)</span>(2, 0.2). Table  translates the estimating equations into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB2_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</code></pre></div>

</div>
<div id="stefanski-boos-example-3" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-3" class="anchor"></a>Stefanski &amp; Boos example 3</h2>
<p>Example 3 illustrates calculation of a ratio estimator. I generate a data set with 100 observations where <span class="math inline">\(Y \sim N\)</span>(5, 4). Table  translates the estimating equations into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN=</span> SB3_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</code></pre></div>

</div>
<div id="stefanski-boos-example-4" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-4" class="anchor"></a>Stefanski &amp; Boos example 4</h2>
<p>Example 4 illustrates calculation of an instumental variable estimator. I generate a data set with 100 observations where INPUT data generation. Table  translates the estimating equations into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB4_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">YW_model &lt;-<span class="st"> </span><span class="kw">lm</span>(Y ~<span class="st"> </span>W, <span class="dt">data =</span> dt)
YT_model &lt;-<span class="st"> </span><span class="kw">lm</span>(Y ~<span class="st"> </span>T_, <span class="dt">data =</span> dt)

WT_model &lt;-<span class="st"> </span><span class="kw">lm</span>(W ~<span class="st"> </span>T_, <span class="dt">data =</span> dt)
## closed form roots
theta_cls &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">theta1 =</span> <span class="kw">mean</span>(dt$T_),
  <span class="dt">theta2 =</span> <span class="kw">mean</span>(dt$W),
  <span class="dt">theta3 =</span> <span class="kw">coef</span>(YW_model)[<span class="dv">2</span>],
  <span class="dt">theta4 =</span> <span class="kw">coef</span>(YT_model)[<span class="dv">2</span>]/<span class="kw">coef</span>(WT_model)[<span class="dv">2</span>])

## closed form covariance
<span class="co"># Not sure how compute SB's closed form since it depends on X, which is</span>
<span class="co"># supposed to be unobserved.</span>
<span class="co"># sigma2_e &lt;- var(residuals(YW_model))</span>
<span class="co"># sigma2_W &lt;- var(dt$W)</span>
<span class="co"># sigma2_U &lt;- var(residuals(YT_model))</span>

<span class="co"># ((sigma_e^2 * (1 + sigma_U^2 * sigma_e^2) + beta^2 * (sigma_U^2 * 1))/(1 + sigma_U^2 * sigma_e^2)^2) / (100^2)</span>
<span class="co"># ((sigma_e^2 * (1 + sigma_U^2 * sigma_e^2) + beta^2 * (sigma_U^2 * 1))/(1 + sigma_U^2 * sigma_e^2)^2) / (100^2)</span>
Sigma_cls &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">2</span>)</code></pre></div>

</div>
<div id="stefanski-boos-example-5" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-5" class="anchor"></a>Stefanski &amp; Boos example 5</h2>
<pre><code>## Loading required package: mvtnorm</code></pre>
<pre><code>## Warning: package 'mvtnorm' was built under R version 3.3.2</code></pre>
<pre><code>## Loading required package: ICS</code></pre>
<pre><code>## Warning: package 'ICS' was built under R version 3.3.2</code></pre>
<p>Example 5 illustrates calculation of an instumental variable estimator. I generate a data set with 100 observations where <span class="math inline">\(X \sim N\)</span>(2, 1). Let <span class="math inline">\(\theta_0 =\)</span> 0. Table  translates the estimating equations for the Hodges-Lehmann location estimation and the sample mean into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">F0 &lt;-<span class="st"> </span>function(y, theta0, <span class="dt">distrFUN =</span> pnorm){
  <span class="kw">distrFUN</span>(y -<span class="st"> </span>theta0, <span class="dt">mean =</span> <span class="dv">0</span>)
}

f0 &lt;-<span class="st"> </span>function(y, densFUN){
  <span class="kw">densFUN</span>(y, <span class="dt">mean =</span> <span class="dv">0</span>)
}

integrand &lt;-<span class="st"> </span>function(y, <span class="dt">densFUN =</span> dnorm){
  <span class="kw">f0</span>(y, <span class="dt">densFUN =</span> densFUN)^<span class="dv">2</span>
}

IC_denom &lt;-<span class="st"> </span><span class="kw">integrate</span>(integrand, <span class="dt">lower =</span> -<span class="ot">Inf</span>, <span class="dt">upper =</span> <span class="ot">Inf</span>)$value

SB5_eefun &lt;-<span class="st"> </span>function(data){
  Xi &lt;-<span class="st"> </span>data$X
  function(theta){
     IC_HL &lt;-<span class="st"> </span>(<span class="dv">1</span>/IC_denom) *<span class="st"> </span>(<span class="kw">F0</span>(Xi, theta[<span class="dv">1</span>]) -<span class="st"> </span><span class="fl">0.5</span>)
     <span class="kw">c</span>(IC_HL,
       Xi -<span class="st"> </span>theta[<span class="dv">2</span>]) 
  }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB5_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">1</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta_cls &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">hl.loc</span>(dt$X), <span class="kw">mean</span>(dt$X))

## closed form covariance
<span class="co"># Not sure how compute SB's closed form since it depends on X, which is</span>
<span class="co"># supposed to be unobserved.</span>
Sigma_cls &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>/(<span class="dv">12</span> *<span class="st"> </span>IC_denom^<span class="dv">2</span>) /<span class="st"> </span>n, <span class="ot">NA</span>, <span class="ot">NA</span>, <span class="kw">var</span>(dt$X)/<span class="dv">100</span>), 
                    <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</code></pre></div>

</div>
<div id="stefanski-boos-example-6" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-6" class="anchor"></a>Stefanski &amp; Boos example 6</h2>
<p>Example 6 illustrates calculation of the Huber estimator of the center of symmetric distributions. I generate a data set with 100 observations where <span class="math inline">\(Y \sim N\)</span>(2, 1). Table  translates the estimating equations for the Huber estimator for the center of symmetric distributions into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB6_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="dv">1</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta_cls &lt;-<span class="st"> </span>MASS::<span class="kw">huber</span>(dt$Y, <span class="dt">tol =</span> <span class="fl">1e-10</span>)$mu

psi_k &lt;-<span class="st"> </span>function(x, <span class="dt">k =</span> <span class="fl">1.5</span>){
  if(<span class="kw">abs</span>(x) &lt;=<span class="st"> </span>k) x else <span class="kw">sign</span>(x) *<span class="st"> </span>k
}

A &lt;-<span class="st"> </span><span class="kw">lapply</span>(dt$Y, function(y){
  x &lt;-<span class="st"> </span>y -<span class="st"> </span>theta_cls
  -numDeriv::<span class="kw">grad</span>(psi_k, <span class="dt">x =</span> x)
}) %&gt;%<span class="st"> </span><span class="kw">unlist</span>() %&gt;%<span class="st"> </span><span class="kw">mean</span>()

B &lt;-<span class="st"> </span><span class="kw">lapply</span>(dt$Y, function(y){
  x &lt;-<span class="st"> </span>y -<span class="st"> </span>theta_cls
  <span class="kw">psi_k</span>(<span class="dt">x =</span> x)^<span class="dv">2</span>
}) %&gt;%<span class="st"> </span><span class="kw">unlist</span>() %&gt;%<span class="st"> </span><span class="kw">mean</span>()

## closed form covariance
Sigma_cls &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>/A *<span class="st"> </span>B *<span class="st"> </span><span class="dv">1</span>/A /<span class="st"> </span>n)</code></pre></div>

</div>
<div id="stefanski-boos-example-7" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-7" class="anchor"></a>Stefanski &amp; Boos example 7</h2>
<p>Example 7 illustrates calculation of sample quantiles using M-estimation. I generate a data set with 100 observations where <span class="math inline">\(Y \sim N\)</span>(2, 1). Table  translates the estimating equations for two sample quantiles (median and 65th percentile) into the <code>R</code> function needed for <code>geex</code>:</p>

<p>This example is <em>under development</em>. The core functions need to be modified in order approximate the <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\psi_i\)</span> functions. I propose to add an additional API that allows users to manipulate these functions. The example below illustate.</p>
<p>I begin with a nondifferentiable <span class="math inline">\(\psi\)</span> function of a single dimension.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">SB7_eefun &lt;-<span class="st"> </span>function(data){
  function(theta){
    <span class="fl">0.5</span>  -<span class="st"> </span>(data$Y &lt;=<span class="st"> </span>theta[<span class="dv">1</span>])
  }
}</code></pre></div>
<p>Here, I modify the <code>eeroot</code> function in order to approximate the <span class="math inline">\(\psi = \sum_i \psi_i\)</span> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eeroot_mod &lt;-<span class="st"> </span>function(geex_list,
                   <span class="dt">start         =</span> <span class="ot">NULL</span>,
                   <span class="dt">rootsolver    =</span> rootSolve::multiroot,
                   <span class="dt">root_options  =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_fun     =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_options =</span> <span class="ot">NULL</span>,
                   ...){

  <span class="co"># Create estimating equation functions per group</span>
  psi_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(geex_list$splitdt, function(data_i){
    geex_list$<span class="kw">eeFUN</span>(<span class="dt">data =</span> data_i, ...)
  })

  <span class="co"># Create psi function that sums over all ee funs</span>
  psi &lt;-<span class="st"> </span>function(theta){
    psii &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(f) {
      <span class="kw">do.call</span>(f, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">theta =</span> theta), geex_list$ee_args))
    })
    <span class="kw">apply</span>(<span class="kw"><a href="../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(psii)), <span class="dv">1</span>, sum)
  }

  <span class="co"># apprx_fun is a function that manipulates the psi function and returns a new psi function</span>
  if(!<span class="kw">is.null</span>(apprx_fun)){
    psi &lt;-<span class="st"> </span><span class="kw">do.call</span>(apprx_fun, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">psi =</span> psi), apprx_options))
  }
  <span class="co"># Find roots of psi</span>
  rargs &lt;-<span class="st"> </span><span class="kw">append</span>(root_options, <span class="kw">list</span>(<span class="dt">f =</span> psi, <span class="dt">start =</span> start))
  <span class="kw">do.call</span>(rootsolver, <span class="dt">args =</span> rargs)
}</code></pre></div>
<p>Here’s an example of how it would work using <code>splinefun</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">spline_approx &lt;-<span class="st"> </span>function(psi, eval_theta){
  ### Use splinefun ####
  psi2 &lt;-<span class="st"> </span><span class="kw">Vectorize</span>(psi)
  psi &lt;-<span class="st"> </span>function(theta) <span class="kw">splinefun</span>(<span class="dt">x =</span> eval_theta, <span class="kw">psi2</span>(eval_theta))(theta)
  psi
}


myList &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">eeFUN =</span> SB7_eefun, <span class="dt">splitdt =</span> <span class="kw">split</span>(dt, <span class="dt">f =</span> dt$id))

root_spline1 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">5</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline1$root</code></pre></div>
<pre><code>## [1] -0.08006065</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline2 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline2$root</code></pre></div>
<pre><code>## [1] 0.02921017</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline3 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> <span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline3$root</code></pre></div>
<pre><code>## [1] -0.08048269</code></pre>
<p>The above method works, but (a) it’s not clear how to choose <code>eval_theta</code> and (b) it would not work with a <span class="math inline">\(\psi\)</span> function of greater than 1 dimension since <code>splinefun</code> only takes univariate arguments.</p>
<p>Here’s an example of how it would work using <code>mgcv::gam</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mgcv)</code></pre></div>
<pre><code>## Loading required package: nlme</code></pre>
<pre><code>## 
## Attaching package: 'nlme'</code></pre>
<pre><code>## The following object is masked from 'package:dplyr':
## 
##     collapse</code></pre>
<pre><code>## This is mgcv 1.8-13. For overview type 'help("mgcv-package")'.</code></pre>
<pre><code>## 
## Attaching package: 'mgcv'</code></pre>
<pre><code>## The following object is masked from 'package:inferference':
## 
##     te</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gam_approx &lt;-<span class="st"> </span>function(psi, eval_theta){
  ### Use splinefun ####
  psi2 &lt;-<span class="st"> </span><span class="kw">Vectorize</span>(psi)
  Y    &lt;-<span class="st"> </span><span class="kw">psi2</span>(eval_theta)
  gam_basis &lt;-<span class="st"> </span><span class="kw">gam</span>(Y ~<span class="st"> </span><span class="kw">s</span>(eval_theta))
  psi &lt;-<span class="st"> </span>function(theta) <span class="kw">predict</span>(gam_basis, <span class="dt">newdata =</span> <span class="kw">data.frame</span>(<span class="dt">eval_theta =</span> theta))
  psi
}

root_gam1 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">3</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam1$root</code></pre></div>
<pre><code>## [1] -0.02318684</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Still, the basis of the spline influences the result</span>
root_gam2 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="fl">1.5</span>, <span class="fl">3.5</span>, <span class="dt">length.out =</span> <span class="dv">20</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam2$root</code></pre></div>
<pre><code>## [1] -0.05344775</code></pre>
<p>What happens when the <span class="math inline">\(n\)</span> increases from 100 to 10000?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Y =</span> <span class="kw">rnorm</span>(n, <span class="dt">mean =</span> theta_tru, <span class="dt">sd =</span> sigma), <span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">10000</span>)
myList2 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">eeFUN =</span> SB7_eefun, <span class="dt">splitdt =</span> <span class="kw">split</span>(dt2, <span class="dt">f =</span> dt2$id))

root_spline4 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="kw">median</span>(dt2$Y) -<span class="st"> </span>root_spline4$root</code></pre></div>
<pre><code>## [1] -0.01297451</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">root_gam3 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam3$root</code></pre></div>
<pre><code>## [1] -0.1546932</code></pre>
<p>In order to compute <span class="math inline">\(A_i\)</span>, we need to approximate <span class="math inline">\(\psi_i\)</span>, so I’ll make a similar modification to <code>compute_matrices</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">compute_matrices_mod &lt;-<span class="st"> </span>function(geex_list,
                             theta,
                             <span class="dt">numDeriv_options =</span> <span class="kw">list</span>(<span class="dt">method =</span> <span class="st">'Richardson'</span>),
                             <span class="dt">silent =</span> <span class="ot">TRUE</span>,
                             <span class="dt">apprx_fun     =</span> <span class="ot">NULL</span>,
                             <span class="dt">apprx_options =</span> <span class="ot">NULL</span>,
                             ...){
  if(<span class="kw">is.null</span>(geex_list$ee_args)){
    ee_args &lt;-<span class="st"> </span><span class="ot">NULL</span>
  }

  <span class="kw">with</span>(geex_list, {

    <span class="co"># Create list of estimating eqn functions per unit</span>
    psi_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(splitdt, function(data_i){
      f &lt;-<span class="st"> </span><span class="kw">eeFUN</span>(<span class="dt">data =</span> data_i, ...)
      if(!<span class="kw">is.null</span>(apprx_fun)){
        f &lt;-<span class="st"> </span><span class="kw">do.call</span>(apprx_fun, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">psi =</span> f), apprx_options))
      }
      f
    })

    <span class="co"># Compute the negative of the derivative matrix of estimating eqn functions</span>
    <span class="co"># (the information matrix)</span>
    A_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(ee){
      args &lt;-<span class="st"> </span><span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">fun =</span> ee, <span class="dt">x =</span> theta), numDeriv_options)
      val  &lt;-<span class="st"> </span><span class="kw">do.call</span>(numDeriv::jacobian, <span class="dt">args =</span> <span class="kw">append</span>(args, ee_args))
      -val
    })
    A_i_array &lt;-<span class="st"> </span><span class="kw"><a href="../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(A_i))
    A   &lt;-<span class="st"> </span><span class="kw">apply</span>(A_i_array, <span class="dv">1</span>:<span class="dv">2</span>, sum)

    <span class="co"># Compute outer product of observed estimating eqns</span>
    B_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(ee) {
      ee_val &lt;-<span class="st"> </span><span class="kw">do.call</span>(ee, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">theta =</span> theta), ee_args))
      ee_val %*%<span class="st"> </span><span class="kw">t</span>(ee_val)
    })
    B   &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="kw"><a href="../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(B_i)), <span class="dv">1</span>:<span class="dv">2</span>, sum)

    <span class="kw">list</span>(<span class="dt">A =</span> A, <span class="dt">A_i =</span> A_i, <span class="dt">B =</span> B, <span class="dt">B_i =</span> B_i)
  })
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">spline_matrices1 &lt;-<span class="st"> </span><span class="kw">compute_matrices_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">theta     =</span> <span class="kw">median</span>(dt$Y),
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dt">by =</span> .<span class="dv">5</span>))
)

<span class="kw"><a href="../reference/compute_sigma.html">compute_sigma</a></span>(<span class="dt">A =</span> spline_matrices1$A, <span class="dt">B =</span> spline_matrices1$B) </code></pre></div>
<pre><code>##            [,1]
## [1,] 0.01925883</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gam_matrices1 &lt;-<span class="st"> </span><span class="kw">compute_matrices_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">theta     =</span> <span class="kw">median</span>(dt$Y),
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dt">by =</span> .<span class="dv">3</span>))
)

<span class="kw"><a href="../reference/compute_sigma.html">compute_sigma</a></span>(<span class="dt">A =</span> gam_matrices1$A, <span class="dt">B =</span> gam_matrices1$B) </code></pre></div>
<pre><code>##            [,1]
## [1,] 0.01164746</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># V(theta) from Stefanski and Boos</span>
((<span class="fl">0.5</span> *<span class="st"> </span>(<span class="dv">1</span> -<span class="fl">0.5</span>))/((<span class="kw">dnorm</span>(<span class="kw">median</span>(dt2$Y), <span class="dt">mean =</span> <span class="kw">mean</span>(dt2$Y), <span class="dt">sd =</span> <span class="kw">sd</span>(dt2$Y)))^<span class="dv">2</span>) ) </code></pre></div>
<pre><code>## [1] 1.552629</code></pre>
<p>For the the quantiles in particular, Stefanski and Boos suggest directly approximating f(theta) by a kernel density. Let’s try that.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dens &lt;-<span class="st"> </span><span class="kw">density</span>(dt$Y)
ff &lt;-<span class="st"> </span><span class="kw">splinefun</span>(<span class="dt">x =</span> dens$x, <span class="dt">y =</span> dens$y)
density_apprx &lt;-<span class="st"> </span>function(psi){
  function(theta) <span class="kw">ff</span>(theta)
}

density_matrices1 &lt;-<span class="st"> </span><span class="kw">compute_matrices_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">theta     =</span> <span class="kw">median</span>(dt$Y),
  <span class="dt">apprx_fun =</span> density_apprx
)

<span class="kw"><a href="../reference/compute_sigma.html">compute_sigma</a></span>(<span class="dt">A =</span> density_matrices1$A, <span class="dt">B =</span> density_matrices1$B) </code></pre></div>
<pre><code>##          [,1]
## [1,] 6.785466</code></pre>
<p>What would happen if instead of approximating <span class="math inline">\(\psi\)</span> for finding roots, we approximated <span class="math inline">\(\psi_i\)</span>? I’m sure it would be slower, but if making same approximations for both situations (finding roots and derivatives of <span class="math inline">\(A_i\)</span>) seems more principled plus the code would be modified in the same location in both <code>eeroot</code> and <code>compute_matrices</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Put apprx_fun code in same place as compute_matrices</span>
eeroot_mod2&lt;-<span class="st"> </span>function(geex_list,
                   <span class="dt">start         =</span> <span class="ot">NULL</span>,
                   <span class="dt">rootsolver    =</span> rootSolve::multiroot,
                   <span class="dt">root_options  =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_fun     =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_options =</span> <span class="ot">NULL</span>,
                   ...){

  <span class="co"># Create estimating equation functions per group</span>
  psi_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(geex_list$splitdt, function(data_i){
      f &lt;-<span class="st"> </span>geex_list$<span class="kw">eeFUN</span>(<span class="dt">data =</span> data_i, ...)
      if(!<span class="kw">is.null</span>(apprx_fun)){
        f &lt;-<span class="st"> </span><span class="kw">do.call</span>(apprx_fun, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">psi =</span> f), apprx_options))
      }
      f
  })

  <span class="co"># Create psi function that sums over all ee funs</span>
  psi &lt;-<span class="st"> </span>function(theta){
    psii &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(f) {
      <span class="kw">do.call</span>(f, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">theta =</span> theta), geex_list$ee_args))
    })
    <span class="kw">apply</span>(<span class="kw"><a href="../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(psii)), <span class="dv">1</span>, sum)
  }
  <span class="co"># Find roots of psi</span>
  rargs &lt;-<span class="st"> </span><span class="kw">append</span>(root_options, <span class="kw">list</span>(<span class="dt">f =</span> psi, <span class="dt">start =</span> start))
  <span class="kw">do.call</span>(rootsolver, <span class="dt">args =</span> rargs)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline5 &lt;-<span class="st"> </span><span class="kw">eeroot_mod2</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> <span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline5$root</code></pre></div>
<pre><code>## [1] -0.08048269</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">root_gam5 &lt;-<span class="st"> </span><span class="kw">eeroot_mod2</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam5$root</code></pre></div>
<pre><code>## [1] -0.03741613</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline6 &lt;-<span class="st"> </span><span class="kw">eeroot_mod2</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> <span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline6$root</code></pre></div>
<pre><code>## [1] -0.197103</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">root_gam6 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam6$root</code></pre></div>
<pre><code>## [1] -0.1546932</code></pre>
<p>Not really.</p>
<p>Now try to approximate a multidimensional <span class="math inline">\(\psi\)</span> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">SB7_eefun2 &lt;-<span class="st"> </span>function(data){
  function(theta){
    <span class="kw">with</span>(data,
    <span class="kw">c</span>(<span class="fl">0.25</span>  -<span class="st"> </span>(Y &lt;=<span class="st"> </span>theta[<span class="dv">1</span>]),
      <span class="fl">0.5</span>   -<span class="st"> </span>(Y &lt;=<span class="st"> </span>theta[<span class="dv">2</span>]),
      <span class="fl">0.75</span>  -<span class="st"> </span>(Y &lt;=<span class="st"> </span>theta[<span class="dv">3</span>]))
    )
  }
}</code></pre></div>
<p>The code next is work in progress. No good, so far.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gam_approx_multi &lt;-<span class="st"> </span>function(psi, eval_theta1, eval_theta2, eval_theta3){
  ### Use splinefun ####
  <span class="co"># psi2 &lt;- Vectorize(psi)</span>
  Y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow =</span> <span class="kw">length</span>(eval_theta1), <span class="dt">ncol =</span> <span class="dv">3</span>)
  for(i in <span class="dv">1</span>:<span class="kw">length</span>(eval_theta1)){
      Y[i, ]  &lt;-<span class="st"> </span><span class="kw">psi</span>(<span class="kw">c</span>(eval_theta1[i], eval_theta2[i], eval_theta3[i]))
  }

  gam_data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
    <span class="dt">Y1 =</span> Y[, <span class="dv">1</span>],
    <span class="dt">Y2 =</span> Y[, <span class="dv">2</span>],
    <span class="dt">Y3 =</span> Y[, <span class="dv">3</span>],
    <span class="dt">x1 =</span> eval_theta1,
    <span class="dt">x2 =</span> eval_theta2,
    <span class="dt">x3 =</span> eval_theta3
  )

  gam_basis &lt;-<span class="st"> </span><span class="kw">gam</span>(<span class="kw">list</span>(Y1 ~<span class="st"> </span><span class="kw">s</span>(x1),
                        Y2 ~<span class="st"> </span><span class="kw">s</span>(x2),
                        Y3 ~<span class="st"> </span><span class="kw">s</span>(x3)),
                   <span class="dt">family =</span> <span class="kw">mvn</span>(<span class="dt">d =</span> <span class="dv">3</span>),
                   <span class="dt">data =</span> gam_data)
  <span class="kw">print</span>(gam_basis)
  psi &lt;-<span class="st"> </span>function(theta) {
    <span class="kw">predict</span>(gam_basis, <span class="dt">newdata =</span> <span class="kw">data.frame</span>(<span class="dt">eval_theta1 =</span> theta[<span class="dv">1</span>],
                                            <span class="dt">eval_theta2 =</span> theta[<span class="dv">2</span>],
                                            <span class="dt">eval_theta3 =</span> theta[<span class="dv">3</span>]))
  }
  psi
}

<span class="kw">SB7_eefun2</span>(dt[<span class="dv">1</span>, ])(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))

myList3 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">eeFUN =</span> SB7_eefun2, <span class="dt">splitdt =</span> <span class="kw">split</span>(dt, <span class="dt">f =</span> dt$id))

root_gam1 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList3,
  <span class="dt">start     =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),
  <span class="dt">apprx_fun =</span> gam_approx_multi,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta1 =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>),
                       <span class="dt">eval_theta2 =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>),
                       <span class="dt">eval_theta3 =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="kw">quantile</span>(dt$Y, <span class="dt">probs =</span> <span class="kw">c</span>(.<span class="dv">25</span>, .<span class="dv">5</span>, .<span class="dv">75</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB7_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">findroots =</span> <span class="ot">FALSE</span>,
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">2</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta_cls &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">quantile</span>(dt$Y, <span class="fl">0.5</span>), <span class="kw">quantile</span>(dt$Y, <span class="fl">0.65</span>))</code></pre></div>
</div>
<div id="stefanski-boos-example-8" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-8" class="anchor"></a>Stefanski &amp; Boos example 8</h2>
<p>Example 8 illustrates robust regression. I generate a data set with 50 observations where half of the observation have <span class="math inline">\(X_i = 1\)</span> and the others have <span class="math inline">\(X_i = 0\)</span>. $Y = $ 0.5 <span class="math inline">\(+\)</span> 2 <span class="math inline">\(X_i + \epsilon_i\)</span> and <span class="math inline">\(\epsilon_i \sim N(0, 1)\)</span>. Table  translates the estimating equations for robust regression into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB8_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span>MASS::<span class="kw">rlm</span>(Y ~<span class="st"> </span>X, <span class="dt">data =</span> dt, <span class="dt">method =</span> <span class="st">'M'</span>)
theta_cls &lt;-<span class="st"> </span><span class="kw">coef</span>(m)
Sigma_cls &lt;-<span class="st"> </span><span class="kw">vcov</span>(m)</code></pre></div>

</div>
<div id="stefanski-boos-example-9" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-9" class="anchor"></a>Stefanski &amp; Boos example 9</h2>
<p>Example 9 illustrates estimation of a generalized linear model. I generate a data set with 100 observations where half of the observation have <span class="math inline">\(X_{1i} = 1\)</span> and the others have <span class="math inline">\(X_{1i} = 0\)</span>. <span class="math inline">\(Y_i \sim Bern[\mbox{logit}^{-1}(\)</span> 0.5 <span class="math inline">\(+\)</span> 2 <span class="math inline">\(X_{1i} +\)</span> 0.1 <span class="math inline">\(X_{2i})]\)</span>. Table  translates the estimating equations for logistic regression into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB9_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">glm</span>(Y ~<span class="st"> </span>X1 +<span class="st"> </span>X2, <span class="dt">data =</span> dt, <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> <span class="st">'logit'</span>))
theta_cls &lt;-<span class="st"> </span><span class="kw">coef</span>(m)
Sigma_cls &lt;-<span class="st"> </span><span class="kw">sandwich</span>(m)</code></pre></div>

</div>
<div id="stefanski-boos-example-10" class="section level2">
<h2 class="hasAnchor">
<a href="#stefanski-boos-example-10" class="anchor"></a>Stefanski &amp; Boos example 10</h2>
<p>Example 10 illustrates testing equality of success probablities. Table  translates the estimating equations into the <code>R</code> function needed for <code>geex</code>:</p>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB10_eefun, 
                                <span class="dt">data  =</span> shaq, 
                                <span class="dt">units =</span> <span class="st">'game'</span>, 
                                <span class="dt">numDeriv_options =</span> <span class="kw">list</span>(<span class="dt">method.args =</span> <span class="kw">list</span>(<span class="dt">eps =</span> <span class="fl">1e-7</span>, <span class="dt">r =</span> <span class="dv">10</span>, <span class="dt">zero.tol =</span> .Machine$double.eps)), 
                                <span class="dt">roots =</span> <span class="kw">c</span>(.<span class="dv">5</span>, .<span class="dv">5</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">V11 &lt;-<span class="st"> </span>function(p) {
  k    &lt;-<span class="st"> </span><span class="kw">nrow</span>(shaq)
  sumn &lt;-<span class="st"> </span><span class="kw">sum</span>(shaq$ft_attp)
  sumn_inv &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="dv">1</span>/shaq$ft_attp)
  term2_n  &lt;-<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span>(<span class="dv">6</span> *<span class="st"> </span>p) +<span class="st"> </span>(<span class="dv">6</span> *<span class="st"> </span>p^<span class="dv">2</span>)
  term2_d &lt;-<span class="st"> </span>p *<span class="st"> </span>(<span class="dv">1</span> -<span class="st"> </span>p) 
  term2  &lt;-<span class="st"> </span>term2_n/term2_d
  term3  &lt;-<span class="st"> </span>((<span class="dv">1</span> -<span class="st"> </span>(<span class="dv">2</span> *<span class="st"> </span>p))^<span class="dv">2</span>) /<span class="st"> </span>((sumn/k) *<span class="st"> </span>p *<span class="st"> </span>(<span class="dv">1</span> -<span class="st"> </span>p))
  <span class="dv">2</span> +<span class="st"> </span>(term2 *<span class="st"> </span>(<span class="dv">1</span>/k) *<span class="st"> </span>sumn_inv) -<span class="st"> </span>term3
}

p_tilde &lt;-<span class="st"> </span><span class="kw">sum</span>(shaq$ft_made)/<span class="kw">sum</span>(shaq$ft_attp)
V11_hat &lt;-<span class="st"> </span><span class="kw">V11</span>(p_tilde)/<span class="dv">23</span>

<span class="co"># Compare variance estimates</span>
V11_hat</code></pre></div>
<pre><code>## [1] 0.0783097</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates$vcov[<span class="dv">1</span>, <span class="dv">1</span>]</code></pre></div>
<pre><code>## [1] 0.1929791</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Compare p-values</span>
<span class="kw">pnorm</span>(<span class="fl">35.51</span>/<span class="dv">23</span>, <span class="dt">mean  =</span> <span class="dv">1</span>, <span class="dt">sd =</span> <span class="kw">sqrt</span>(V11_hat), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] 0.02596785</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pnorm</span>(estimates$parameters[<span class="dv">1</span>], 
      <span class="dt">mean =</span> <span class="dv">1</span>, 
      <span class="dt">sd =</span> <span class="kw">sqrt</span>(estimates$vcov[<span class="dv">1</span>, <span class="dv">1</span>]),
      <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] 0.1078138</code></pre>
</div>
<div id="small-sample-corrections-of-fay-2001" class="section level1">
<h1 class="hasAnchor">
<a href="#small-sample-corrections-of-fay-2001" class="anchor"></a>Small Sample Corrections of Fay (2001)</h1>
<div id="bias-correction" class="section level2">
<h2 class="hasAnchor">
<a href="#bias-correction" class="anchor"></a>Bias correction</h2>
<p><span class="math display">\[
H_i = \{1 - min(b, \{A_i A\}_{jj}) \}^{-1/2}
\]</span> Where <span class="math inline">\(b\)</span> is a constant chosen by the analyst. Fay lets <span class="math inline">\(b = 0.75\)</span>. Note that <span class="math inline">\(H_i\)</span> is a diagonal matrix.</p>
<p><span class="math display">\[
B^{bc}_i = H_i \psi_i \psi_i^T H_i
\]</span></p>
<p><span class="math display">\[
B^{bc} = \sum_{i = 1}^m B^{bc}_i
\]</span></p>
<p><span class="math display">\[
\Sigma^{bc} = A^{-1} B^{bc} \{A^{-1}\}^T
\]</span></p>
<div id="degrees-of-freedom-corrections" class="section level3">
<h3 class="hasAnchor">
<a href="#degrees-of-freedom-corrections" class="anchor"></a>Degrees of Freedom corrections</h3>
<p>Let <span class="math inline">\(L\)</span> be the contrast of interest (e.g.) <span class="math inline">\((0, \dots, 0, 1, -1)\)</span> for a causal difference when the last two elements of the estimating equations are the counterfactual means.</p>
<p><span class="math display">\[
\mathcal{I} = [I_p \cdots I_p]
\]</span></p>
<p>where <span class="math inline">\(I_p\)</span> is a <span class="math inline">\(p \times p\)</span> identity matrix.</p>
<p><span class="math display">\[
G = I_{pm} - \begin{bmatrix}A^{bc}_1 \\ \vdots \\ A_m \end{bmatrix} A^{-1} \mathcal{I} 
\]</span></p>
<p><span class="math display">\[
M = diag\{H_i A^{-1} L L^T (A^{-1})^T H_i \}
\]</span></p>
<p><span class="math display">\[
C = G^T M G
\]</span></p>
<p><span class="math display">\[
w_i = L^T \left[ \left\{\sum_{j \neq i} A_i \right\}^{-1} - A^{-1} \right] L
\]</span></p>
<p><span class="math display">\[
\bar{w} = \sum_{i = 1}^m w_i
\]</span></p>
<p><span class="math display">\[
A^{bc}_i = \frac{w_i}{\bar{w}} B^{bc}
\]</span></p>
<p><span class="math display">\[
\hat{df}_1 = \frac{ \left\{ Tr( diag(A_i) C ) \right\}^2  }{ Tr( diag(A_i) C diag(A_i) C)}  
\]</span></p>
<p><span class="math display">\[
\hat{df}_2 = \frac{ \left\{ Tr( diag(A^{bc}_i) C ) \right\}^2  }{ Tr( diag(A^{bc}_i) C diag(A^{bc}_i) C)}  
\]</span></p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#basic-setup">Basic Setup</a></li>
      <li><a href="#stefanski-boos-example-1">Stefanski &amp; Boos example 1</a></li>
      <li><a href="#stefanski-boos-example-2">Stefanski &amp; Boos example 2</a></li>
      <li><a href="#stefanski-boos-example-3">Stefanski &amp; Boos example 3</a></li>
      <li><a href="#stefanski-boos-example-4">Stefanski &amp; Boos example 4</a></li>
      <li><a href="#stefanski-boos-example-5">Stefanski &amp; Boos example 5</a></li>
      <li><a href="#stefanski-boos-example-6">Stefanski &amp; Boos example 6</a></li>
      <li><a href="#stefanski-boos-example-7">Stefanski &amp; Boos example 7</a></li>
      <li><a href="#stefanski-boos-example-8">Stefanski &amp; Boos example 8</a></li>
      <li><a href="#stefanski-boos-example-9">Stefanski &amp; Boos example 9</a></li>
      <li><a href="#stefanski-boos-example-10">Stefanski &amp; Boos example 10</a></li>
      <li>
<a href="#small-sample-corrections-of-fay-2001">Small Sample Corrections of Fay (2001)</a><ul class="nav nav-pills nav-stacked">
<li><a href="#bias-correction">Bias correction</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bradley Saul.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
