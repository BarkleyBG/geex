<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title> • geex</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../jquery.sticky-kit.min.js"></script><script src="../../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../../index.html">geex</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li>
  <a href="../../articles/index.html">Articles</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1></h1>
            
          </div>

    
    
<div class="contents">
<pre><code>## 
## Attaching package: 'dplyr'</code></pre>
<pre><code>## The following objects are masked from 'package:stats':
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union</code></pre>
<p>Example 7 illustrates calculation of sample quantiles using M-estimation. I generate a data set with 100 observations where <span class="math inline">\(Y \sim N\)</span>(2, 1). Table  translates the estimating equations for two sample quantiles (median and 65th percentile) into the <code>R</code> function needed for <code>geex</code>:</p>

<p>This example is <em>under development</em>. The core functions need to be modified in order approximate the <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\psi_i\)</span> functions. I propose to add an additional API that allows users to manipulate these functions. The example below illustate.</p>
<p>I begin with a nondifferentiable <span class="math inline">\(\psi\)</span> function of a single dimension.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">SB7_eefun &lt;-<span class="st"> </span>function(data){
  function(theta){
    <span class="fl">0.5</span>  -<span class="st"> </span>(data$Y &lt;=<span class="st"> </span>theta[<span class="dv">1</span>])
  }
}</code></pre></div>
<p>Here, I modify the <code>eeroot</code> function in order to approximate the <span class="math inline">\(\psi = \sum_i \psi_i\)</span> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eeroot_mod &lt;-<span class="st"> </span>function(geex_list,
                   <span class="dt">start         =</span> <span class="ot">NULL</span>,
                   <span class="dt">rootsolver    =</span> rootSolve::multiroot,
                   <span class="dt">root_options  =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_fun     =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_options =</span> <span class="ot">NULL</span>,
                   ...){

  <span class="co"># Create estimating equation functions per group</span>
  psi_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(geex_list$splitdt, function(data_i){
    geex_list$<span class="kw">eeFUN</span>(<span class="dt">data =</span> data_i, ...)
  })

  <span class="co"># Create psi function that sums over all ee funs</span>
  psi &lt;-<span class="st"> </span>function(theta){
    psii &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(f) {
      <span class="kw">do.call</span>(f, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">theta =</span> theta), geex_list$ee_args))
    })
    <span class="kw">apply</span>(<span class="kw"><a href="../../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(psii)), <span class="dv">1</span>, sum)
  }

  <span class="co"># apprx_fun is a function that manipulates the psi function and returns a new psi function</span>
  if(!<span class="kw">is.null</span>(apprx_fun)){
    psi &lt;-<span class="st"> </span><span class="kw">do.call</span>(apprx_fun, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">psi =</span> psi), apprx_options))
  }
  <span class="co"># Find roots of psi</span>
  rargs &lt;-<span class="st"> </span><span class="kw">append</span>(root_options, <span class="kw">list</span>(<span class="dt">f =</span> psi, <span class="dt">start =</span> start))
  <span class="kw">do.call</span>(rootsolver, <span class="dt">args =</span> rargs)
}</code></pre></div>
<p>Here’s an example of how it would work using <code>splinefun</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">spline_approx &lt;-<span class="st"> </span>function(psi, eval_theta){
  ### Use splinefun ####
  psi2 &lt;-<span class="st"> </span><span class="kw">Vectorize</span>(psi)
  psi &lt;-<span class="st"> </span>function(theta) <span class="kw">splinefun</span>(<span class="dt">x =</span> eval_theta, <span class="kw">psi2</span>(eval_theta))(theta)
  psi
}


myList &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">eeFUN =</span> SB7_eefun, <span class="dt">splitdt =</span> <span class="kw">split</span>(dt, <span class="dt">f =</span> dt$id))

root_spline1 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">5</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline1$root</code></pre></div>
<pre><code>## [1] -0.08006065</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline2 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline2$root</code></pre></div>
<pre><code>## [1] 0.02921017</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline3 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> <span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline3$root</code></pre></div>
<pre><code>## [1] -0.08048269</code></pre>
<p>The above method works, but (a) it’s not clear how to choose <code>eval_theta</code> and (b) it would not work with a <span class="math inline">\(\psi\)</span> function of greater than 1 dimension since <code>splinefun</code> only takes univariate arguments.</p>
<p>Here’s an example of how it would work using <code>mgcv::gam</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mgcv)</code></pre></div>
<pre><code>## Loading required package: nlme</code></pre>
<pre><code>## 
## Attaching package: 'nlme'</code></pre>
<pre><code>## The following object is masked from 'package:dplyr':
## 
##     collapse</code></pre>
<pre><code>## This is mgcv 1.8-13. For overview type 'help("mgcv-package")'.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gam_approx &lt;-<span class="st"> </span>function(psi, eval_theta){
  ### Use splinefun ####
  psi2 &lt;-<span class="st"> </span><span class="kw">Vectorize</span>(psi)
  Y    &lt;-<span class="st"> </span><span class="kw">psi2</span>(eval_theta)
  gam_basis &lt;-<span class="st"> </span><span class="kw">gam</span>(Y ~<span class="st"> </span><span class="kw">s</span>(eval_theta))
  psi &lt;-<span class="st"> </span>function(theta) <span class="kw">predict</span>(gam_basis, <span class="dt">newdata =</span> <span class="kw">data.frame</span>(<span class="dt">eval_theta =</span> theta))
  psi
}

root_gam1 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">3</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam1$root</code></pre></div>
<pre><code>## [1] -0.02318684</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Still, the basis of the spline influences the result</span>
root_gam2 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="fl">1.5</span>, <span class="fl">3.5</span>, <span class="dt">length.out =</span> <span class="dv">20</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam2$root</code></pre></div>
<pre><code>## [1] -0.05344775</code></pre>
<p>What happens when the <span class="math inline">\(n\)</span> increases from 100 to 10000?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Y =</span> <span class="kw">rnorm</span>(n, <span class="dt">mean =</span> theta_tru, <span class="dt">sd =</span> sigma), <span class="dt">id =</span> <span class="dv">1</span>:<span class="dv">10000</span>)
myList2 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">eeFUN =</span> SB7_eefun, <span class="dt">splitdt =</span> <span class="kw">split</span>(dt2, <span class="dt">f =</span> dt2$id))

root_spline4 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="kw">median</span>(dt2$Y) -<span class="st"> </span>root_spline4$root</code></pre></div>
<pre><code>## [1] -0.01297451</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">root_gam3 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam3$root</code></pre></div>
<pre><code>## [1] -0.1546932</code></pre>
<p>In order to compute <span class="math inline">\(A_i\)</span>, we need to approximate <span class="math inline">\(\psi_i\)</span>, so I’ll make a similar modification to <code>compute_matrices</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">compute_matrices_mod &lt;-<span class="st"> </span>function(geex_list,
                             theta,
                             <span class="dt">numDeriv_options =</span> <span class="kw">list</span>(<span class="dt">method =</span> <span class="st">'Richardson'</span>),
                             <span class="dt">silent =</span> <span class="ot">TRUE</span>,
                             <span class="dt">apprx_fun     =</span> <span class="ot">NULL</span>,
                             <span class="dt">apprx_options =</span> <span class="ot">NULL</span>,
                             ...){
  if(<span class="kw">is.null</span>(geex_list$ee_args)){
    ee_args &lt;-<span class="st"> </span><span class="ot">NULL</span>
  }

  <span class="kw">with</span>(geex_list, {

    <span class="co"># Create list of estimating eqn functions per unit</span>
    psi_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(splitdt, function(data_i){
      f &lt;-<span class="st"> </span><span class="kw">eeFUN</span>(<span class="dt">data =</span> data_i, ...)
      if(!<span class="kw">is.null</span>(apprx_fun)){
        f &lt;-<span class="st"> </span><span class="kw">do.call</span>(apprx_fun, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">psi =</span> f), apprx_options))
      }
      f
    })

    <span class="co"># Compute the negative of the derivative matrix of estimating eqn functions</span>
    <span class="co"># (the information matrix)</span>
    A_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(ee){
      args &lt;-<span class="st"> </span><span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">fun =</span> ee, <span class="dt">x =</span> theta), numDeriv_options)
      val  &lt;-<span class="st"> </span><span class="kw">do.call</span>(numDeriv::jacobian, <span class="dt">args =</span> <span class="kw">append</span>(args, ee_args))
      -val
    })
    A_i_array &lt;-<span class="st"> </span><span class="kw"><a href="../../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(A_i))
    A   &lt;-<span class="st"> </span><span class="kw">apply</span>(A_i_array, <span class="dv">1</span>:<span class="dv">2</span>, sum)

    <span class="co"># Compute outer product of observed estimating eqns</span>
    B_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(ee) {
      ee_val &lt;-<span class="st"> </span><span class="kw">do.call</span>(ee, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">theta =</span> theta), ee_args))
      ee_val %*%<span class="st"> </span><span class="kw">t</span>(ee_val)
    })
    B   &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="kw"><a href="../../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(B_i)), <span class="dv">1</span>:<span class="dv">2</span>, sum)

    <span class="kw">list</span>(<span class="dt">A =</span> A, <span class="dt">A_i =</span> A_i, <span class="dt">B =</span> B, <span class="dt">B_i =</span> B_i)
  })
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">spline_matrices1 &lt;-<span class="st"> </span><span class="kw">compute_matrices_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">theta     =</span> <span class="kw">median</span>(dt$Y),
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dt">by =</span> .<span class="dv">5</span>))
)

<span class="kw"><a href="../../reference/compute_sigma.html">compute_sigma</a></span>(<span class="dt">A =</span> spline_matrices1$A, <span class="dt">B =</span> spline_matrices1$B) </code></pre></div>
<pre><code>##            [,1]
## [1,] 0.01925883</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gam_matrices1 &lt;-<span class="st"> </span><span class="kw">compute_matrices_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">theta     =</span> <span class="kw">median</span>(dt$Y),
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dt">by =</span> .<span class="dv">3</span>))
)

<span class="kw"><a href="../../reference/compute_sigma.html">compute_sigma</a></span>(<span class="dt">A =</span> gam_matrices1$A, <span class="dt">B =</span> gam_matrices1$B) </code></pre></div>
<pre><code>##            [,1]
## [1,] 0.01164746</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># V(theta) from Stefanski and Boos</span>
((<span class="fl">0.5</span> *<span class="st"> </span>(<span class="dv">1</span> -<span class="fl">0.5</span>))/((<span class="kw">dnorm</span>(<span class="kw">median</span>(dt2$Y), <span class="dt">mean =</span> <span class="kw">mean</span>(dt2$Y), <span class="dt">sd =</span> <span class="kw">sd</span>(dt2$Y)))^<span class="dv">2</span>) ) </code></pre></div>
<pre><code>## [1] 1.552629</code></pre>
<p>For the the quantiles in particular, Stefanski and Boos suggest directly approximating f(theta) by a kernel density. Let’s try that.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dens &lt;-<span class="st"> </span><span class="kw">density</span>(dt$Y)
ff &lt;-<span class="st"> </span><span class="kw">splinefun</span>(<span class="dt">x =</span> dens$x, <span class="dt">y =</span> dens$y)
density_apprx &lt;-<span class="st"> </span>function(psi){
  function(theta) <span class="kw">ff</span>(theta)
}

density_matrices1 &lt;-<span class="st"> </span><span class="kw">compute_matrices_mod</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">theta     =</span> <span class="kw">median</span>(dt$Y),
  <span class="dt">apprx_fun =</span> density_apprx
)

<span class="kw"><a href="../../reference/compute_sigma.html">compute_sigma</a></span>(<span class="dt">A =</span> density_matrices1$A, <span class="dt">B =</span> density_matrices1$B) </code></pre></div>
<pre><code>##          [,1]
## [1,] 6.785466</code></pre>
<p>What would happen if instead of approximating <span class="math inline">\(\psi\)</span> for finding roots, we approximated <span class="math inline">\(\psi_i\)</span>? I’m sure it would be slower, but if making same approximations for both situations (finding roots and derivatives of <span class="math inline">\(A_i\)</span>) seems more principled plus the code would be modified in the same location in both <code>eeroot</code> and <code>compute_matrices</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Put apprx_fun code in same place as compute_matrices</span>
eeroot_mod2&lt;-<span class="st"> </span>function(geex_list,
                   <span class="dt">start         =</span> <span class="ot">NULL</span>,
                   <span class="dt">rootsolver    =</span> rootSolve::multiroot,
                   <span class="dt">root_options  =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_fun     =</span> <span class="ot">NULL</span>,
                   <span class="dt">apprx_options =</span> <span class="ot">NULL</span>,
                   ...){

  <span class="co"># Create estimating equation functions per group</span>
  psi_i &lt;-<span class="st"> </span><span class="kw">lapply</span>(geex_list$splitdt, function(data_i){
      f &lt;-<span class="st"> </span>geex_list$<span class="kw">eeFUN</span>(<span class="dt">data =</span> data_i, ...)
      if(!<span class="kw">is.null</span>(apprx_fun)){
        f &lt;-<span class="st"> </span><span class="kw">do.call</span>(apprx_fun, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">psi =</span> f), apprx_options))
      }
      f
  })

  <span class="co"># Create psi function that sums over all ee funs</span>
  psi &lt;-<span class="st"> </span>function(theta){
    psii &lt;-<span class="st"> </span><span class="kw">lapply</span>(psi_i, function(f) {
      <span class="kw">do.call</span>(f, <span class="dt">args =</span> <span class="kw">append</span>(<span class="kw">list</span>(<span class="dt">theta =</span> theta), geex_list$ee_args))
    })
    <span class="kw">apply</span>(<span class="kw"><a href="../../reference/check_array.html">check_array</a></span>(<span class="kw">simplify2array</span>(psii)), <span class="dv">1</span>, sum)
  }
  <span class="co"># Find roots of psi</span>
  rargs &lt;-<span class="st"> </span><span class="kw">append</span>(root_options, <span class="kw">list</span>(<span class="dt">f =</span> psi, <span class="dt">start =</span> start))
  <span class="kw">do.call</span>(rootsolver, <span class="dt">args =</span> rargs)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline5 &lt;-<span class="st"> </span><span class="kw">eeroot_mod2</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> <span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline5$root</code></pre></div>
<pre><code>## [1] -0.08048269</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">root_gam5 &lt;-<span class="st"> </span><span class="kw">eeroot_mod2</span>(
  <span class="dt">geex_list =</span> myList,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam5$root</code></pre></div>
<pre><code>## [1] -0.03741613</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># But notice that the basis of the spline matters too</span>
root_spline6 &lt;-<span class="st"> </span><span class="kw">eeroot_mod2</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> spline_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> <span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_spline6$root</code></pre></div>
<pre><code>## [1] -0.197103</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">root_gam6 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList2,
  <span class="dt">start     =</span> <span class="dv">2</span>,
  <span class="dt">apprx_fun =</span> gam_approx,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="co"># Compare to the truth</span>
<span class="kw">median</span>(dt$Y) -<span class="st"> </span>root_gam6$root</code></pre></div>
<pre><code>## [1] -0.1546932</code></pre>
<p>Not really.</p>
<p>Now try to approximate a multidimensional <span class="math inline">\(\psi\)</span> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">SB7_eefun2 &lt;-<span class="st"> </span>function(data){
  function(theta){
    <span class="kw">with</span>(data,
    <span class="kw">c</span>(<span class="fl">0.25</span>  -<span class="st"> </span>(Y &lt;=<span class="st"> </span>theta[<span class="dv">1</span>]),
      <span class="fl">0.5</span>   -<span class="st"> </span>(Y &lt;=<span class="st"> </span>theta[<span class="dv">2</span>]),
      <span class="fl">0.75</span>  -<span class="st"> </span>(Y &lt;=<span class="st"> </span>theta[<span class="dv">3</span>]))
    )
  }
}</code></pre></div>
<p>The code next is work in progress. No good, so far.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gam_approx_multi &lt;-<span class="st"> </span>function(psi, eval_theta1, eval_theta2, eval_theta3){
  ### Use splinefun ####
  <span class="co"># psi2 &lt;- Vectorize(psi)</span>
  Y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow =</span> <span class="kw">length</span>(eval_theta1), <span class="dt">ncol =</span> <span class="dv">3</span>)
  for(i in <span class="dv">1</span>:<span class="kw">length</span>(eval_theta1)){
      Y[i, ]  &lt;-<span class="st"> </span><span class="kw">psi</span>(<span class="kw">c</span>(eval_theta1[i], eval_theta2[i], eval_theta3[i]))
  }

  gam_data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
    <span class="dt">Y1 =</span> Y[, <span class="dv">1</span>],
    <span class="dt">Y2 =</span> Y[, <span class="dv">2</span>],
    <span class="dt">Y3 =</span> Y[, <span class="dv">3</span>],
    <span class="dt">x1 =</span> eval_theta1,
    <span class="dt">x2 =</span> eval_theta2,
    <span class="dt">x3 =</span> eval_theta3
  )

  gam_basis &lt;-<span class="st"> </span><span class="kw">gam</span>(<span class="kw">list</span>(Y1 ~<span class="st"> </span><span class="kw">s</span>(x1),
                        Y2 ~<span class="st"> </span><span class="kw">s</span>(x2),
                        Y3 ~<span class="st"> </span><span class="kw">s</span>(x3)),
                   <span class="dt">family =</span> <span class="kw">mvn</span>(<span class="dt">d =</span> <span class="dv">3</span>),
                   <span class="dt">data =</span> gam_data)
  <span class="kw">print</span>(gam_basis)
  psi &lt;-<span class="st"> </span>function(theta) {
    <span class="kw">predict</span>(gam_basis, <span class="dt">newdata =</span> <span class="kw">data.frame</span>(<span class="dt">eval_theta1 =</span> theta[<span class="dv">1</span>],
                                            <span class="dt">eval_theta2 =</span> theta[<span class="dv">2</span>],
                                            <span class="dt">eval_theta3 =</span> theta[<span class="dv">3</span>]))
  }
  psi
}

<span class="kw">SB7_eefun2</span>(dt[<span class="dv">1</span>, ])(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))

myList3 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">eeFUN =</span> SB7_eefun2, <span class="dt">splitdt =</span> <span class="kw">split</span>(dt, <span class="dt">f =</span> dt$id))

root_gam1 &lt;-<span class="st"> </span><span class="kw">eeroot_mod</span>(
  <span class="dt">geex_list =</span> myList3,
  <span class="dt">start     =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),
  <span class="dt">apprx_fun =</span> gam_approx_multi,
  <span class="dt">apprx_options =</span> <span class="kw">list</span>(<span class="dt">eval_theta1 =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>),
                       <span class="dt">eval_theta2 =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>),
                       <span class="dt">eval_theta3 =</span> <span class="kw">seq</span>(-<span class="dv">5</span>, <span class="dv">5</span>, <span class="dt">by =</span> .<span class="dv">1</span>))
)

<span class="kw">quantile</span>(dt$Y, <span class="dt">probs =</span> <span class="kw">c</span>(.<span class="dv">25</span>, .<span class="dv">5</span>, .<span class="dv">75</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">estimates &lt;-<span class="st"> </span><span class="kw"><a href="../../reference/estimate_equations.html">estimate_equations</a></span>(<span class="dt">eeFUN =</span> SB7_eefun, 
                                <span class="dt">data  =</span> dt, <span class="dt">units =</span> <span class="st">'id'</span>, 
                                <span class="dt">findroots =</span> <span class="ot">FALSE</span>,
                                <span class="dt">roots =</span> <span class="kw">c</span>(<span class="dv">2</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta_cls &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">quantile</span>(dt$Y, <span class="fl">0.5</span>), <span class="kw">quantile</span>(dt$Y, <span class="fl">0.65</span>))</code></pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bradley Saul.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
