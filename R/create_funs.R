#------------------------------------------------------------------------------#
# create_** description:
# Functions that take in stuff and create a function or list of functions.
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
#' Creates list of psi functions
#'
#' Creates the estimating function (\eqn{\psi(O_i, \theta)}{\psi(O_i, \theta)})
#' for each unit. That is, this function evaluates the outer function in
#' \code{estFUN} for each independent unit and a returns the inner function in
#' \code{estFUN}.
#'
#' @param .basis an object of class \code{\linkS4class{m_estimation_basis}}
#' @param .approx_control an object of class \code{\linkS4class{approx_control}}
#' or \code{NULL}
#' @return a list of functions, each function corresponding to a single unit
#' @export
#'
#------------------------------------------------------------------------------#

create_psi <- function(.basis,
                       .approx_control){

  out <- lapply(.basis@.split_data, function(data_i){
    do.call(grab_estFUN(.basis),
            args = append(list(data = data_i), .basis@.outer_args))
  })

  # if user specifies an approximation function, apply the function to each
  # evaluation of psi

  # Use approx_control defaults if no options passed
  if(missing(.approx_control)){
    .approx_control <- new('approx_control')
  }

  if(!(is.null(body(FUN(.approx_control))))){
    approxFUN <- match.call(FUN(.approx_control))
    lapply(out, function(f){
      do.call(approxFUN, args = append(list(psi = f), options(.approx_control)))
    }) -> out
  }

  out
}

#------------------------------------------------------------------------------#
#' Creates a function that sums over psi functions
#'
#' From a list of \eqn{\psi(O_i, \theta)}{\psi(O_i, \theta)} for i = 1, ..., m,
#' creates \eqn{G_m = \sum_i \psi(O_i, \theta)}{G_m = \sum_i \psi(O_i, \theta)},
#' called \code{GFUN}. Here, \eqn{\psi(O_i, \theta)}{\psi(O_i, \theta)} is the
#' *inner* part of an \code{estFUN}, in that the data is fixed and \eqn{G_m}{G_m}
#' is a function of \eqn{\theta)}{\theta}.
#'
#' @param .psi_list list of psi functions generated by \code{\link{create_psi}}
#' @param .inner_estFUN_args list of arguments passed to psi
#' @export
#'
#------------------------------------------------------------------------------#

create_GFUN <- function(.psi_list,
                        .inner_estFUN_args = NULL,
                        .weights = NULL){
  function(theta){
    psii <- lapply(.psi_list, function(psi) {
      do.call(psi, args = append(list(theta = theta), .inner_estFUN_args))
    })

    # If weights are provided, then multiply each psi function by its
    # respective weight
    if(length(.weights) == 0){
      psii_array <- simplify2array(psii)
    } else {
      psii_array <- simplify2array(Map(`*`, psii, .weights))
    }
    # sum over unit-wise contributions to the estimating equations
    apply(check_array(psii_array), 1, sum)
  }
}
