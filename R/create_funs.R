#------------------------------------------------------------------------------#
# create_** description:
# Functions that take in stuff and create a function or list of functions.
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
#' Creates list of psi functions
#'
#' Creates the estimating function (\eqn{\psi(O_i, \theta)}{\psi(O_i, \theta)})
#' for each unit. That is, this function evaluates the outer function in \code{eeFUN}
#' for each independent unit and a returns the inner function in \code{eeFUN}.
#'
#' @param .split_data list of dataframes with data per unit
#' @param .estFUN the estimating equation function
#' @param approxFUN a function that approximates the inner function of \code{eeFUN}.
#' (EXPERIMENTAL).
#' @param approxFUN_control arguments passed to \code{approxFUN}
#' @param .outer_estFUN_args a list of arguments passed to \code{eeFUN}
#' @return a list of functions, each function corresponding to a single unit
#' @export
#'
#------------------------------------------------------------------------------#

create_psi <- function(.split_data,
                       .estFUN,
                       approxFUN = NULL,
                       approxFUN_control = NULL,
                       .outer_estFUN_args = NULL){
  out <- lapply(.split_data, function(data_i){
    do.call(.estFUN, args = append(list(data = data_i), .outer_estFUN_args))
  })

  # if user specifies an approximation function, apply the function to each
  # evaluation of psi
  if(!is.null(approxFUN)){
    lapply(out, function(f){
      do.call(approxFUN, args = append(list(psi = f), approxFUN_control))
    }) -> out
  }

  out
}

#------------------------------------------------------------------------------#
#' Creates a function that sums over psi functions
#'
#' From a list of \eqn{\psi(O_i, \theta)}{\psi(O_i, \theta)} for i = 1, ..., m,
#' creates \eqn{G_m = \sum_i \psi(O_i, \theta)}{G_m = \sum_i \psi(O_i, \theta)},
#' called \code{GFUN}. Here, \eqn{\psi(O_i, \theta)}{\psi(O_i, \theta)} is the
#' *inner* part of an \code{estFUN}, in that the data is fixed and \eqn{G_m}{G_m}
#' is a function of \eqn{\theta)}{\theta}.
#'
#' @param .psi_list list of psi functions generated by \code{\link{create_psi}}
#' @param .inner_estFUN_args list of arguments passed to psi
#' @export
#'
#------------------------------------------------------------------------------#

create_GFUN <- function(.psi_list,
                        .inner_estFUN_args = NULL,
                        .weights = NULL){
  function(theta){
    psii <- lapply(.psi_list, function(psi) {
      do.call(psi, args = append(list(theta = theta), .inner_estFUN_args))
    })

    # If weights are provided, then multiply each psi function by its
    # respective weight
    if(length(.weights) == 0){
      psii_array <- simplify2array(psii)
    } else {
      psii_array <- simplify2array(Map(`*`, psii, .weights))
    }
    # sum over unit-wise contributions to the estimating equations
    apply(check_array(psii_array), 1, sum)
  }
}
