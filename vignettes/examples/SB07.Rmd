---
output: pdf_document
---

```{r SB7_setup, echo=FALSE}
library(geex)
library(dplyr)
set.seed(9)
n <- 100
theta_tru <- 2
sigma <- 1
dt <- data.frame(Y = rnorm(n, mean = theta_tru, sd = sigma), id = 1:n)
```

Example 7 illustrates calculation of sample quantiles using M-estimation. I generate a data set with `r n` observations where $Y \sim N$(`r theta_tru`, `r sigma`). Table \ref{ex7} translates the estimating equations for two sample quantiles (median and 65th percentile) into the `R` function needed for `geex`:

\begin{table}[H]
\centering
\label{ex7}
\caption{Translating math to code}
\begin{tabular}{cc}
$\psi_k(Y_i, \theta) = 
\begin{pmatrix}
0.5 - I(Y_i \leq \theta_1) \\
0.65 - I(Y_i \leq \theta_2) 
\end{pmatrix}$ &
\begin{minipage}{3in}
\begin{verbatim}
SB7_eefun <- function(data){
  function(theta){
    with(data,
      c(0.5  - (Y <= theta[1]),
        0.65 - (Y <= theta[2]))
    )
  }
}
\end{verbatim}
\end{minipage}
\end{tabular}
\end{table}

This example is *under development*. The core functions need to be modified in order approximate the $\psi$ and $\psi_i$ functions. I propose to add an additional API that allows users to manipulate these functions. The example below illustate. 

I begin with a nondifferentiable $\psi$ function of a single dimension.
```{r SB7_eefun, echo = TRUE}
SB7_eefun <- function(data){
  function(theta){
    0.5  - (data$Y <= theta[1])
  }
}
```

```{r check_array, echo = FALSE, eval = TRUE}
# this is not an exported function from geex, so add it here
check_array <- function(object){
  if(is.array(object)){
    object
  } else if(is.numeric(object)){
    array(object, dim = c(1, 1, length(object)))
  } else if(is.matrix(object)){
    array(object, dim = c(1, 1, length(object)))
  } else {
    stop('Object is not an array, matrix, or numeric')
  }
}
```

Here, I modify the `eeroot` function in order to approximate the $\psi = \sum_i \psi_i$ function.

```{r eeroot_modified, echo = TRUE, eval=TRUE}
eeroot_mod <- function(geex_list,
                   start         = NULL,
                   rootsolver    = rootSolve::multiroot,
                   root_options  = NULL,
                   apprx_fun     = NULL,
                   apprx_options = NULL,
                   ...){

  # Create estimating equation functions per group
  psi_i <- lapply(geex_list$splitdt, function(data_i){
    geex_list$eeFUN(data = data_i, ...)
  })

  # Create psi function that sums over all ee funs
  psi <- function(theta){
    psii <- lapply(psi_i, function(f) {
      do.call(f, args = append(list(theta = theta), geex_list$ee_args))
    })
    apply(check_array(simplify2array(psii)), 1, sum)
  }

  # apprx_fun is a function that manipulates the psi function and returns a new psi function
  if(!is.null(apprx_fun)){
    psi <- do.call(apprx_fun, args = append(list(psi = psi), apprx_options))
  }
  # Find roots of psi
  rargs <- append(root_options, list(f = psi, start = start))
  do.call(rootsolver, args = rargs)
}
```

Here's an example of how it would work using `splinefun`.

```{r splinefun, echo = TRUE}
spline_approx <- function(psi, eval_theta){
  ### Use splinefun ####
  psi2 <- Vectorize(psi)
  psi <- function(theta) splinefun(x = eval_theta, psi2(eval_theta))(theta)
  psi
}


myList <- list(eeFUN = SB7_eefun, splitdt = split(dt, f = dt$id))

root_spline1 <- eeroot_mod(
  geex_list = myList,
  start     = 2,
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(1, 5, by = .5))
)

# Compare to the truth
median(dt$Y) - root_spline1$root

# But notice that the basis of the spline matters too
root_spline2 <- eeroot_mod(
  geex_list = myList,
  start     = 2,
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(1, 5, by = .1))
)

# Compare to the truth
median(dt$Y) - root_spline2$root


# But notice that the basis of the spline matters too
root_spline3 <- eeroot_mod(
  geex_list = myList,
  start     = 2,
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(-5, 5, by = 1))
)

# Compare to the truth
median(dt$Y) - root_spline3$root

```

The above method works, but (a) it's not clear how to choose `eval_theta` and (b) it would not work with a $\psi$ function of greater than 1 dimension since `splinefun` only takes univariate arguments.

Here's an example of how it would work using `mgcv::gam`.

```{r gam_approx, echo = TRUE}
library(mgcv)
gam_approx <- function(psi, eval_theta){
  ### Use splinefun ####
  psi2 <- Vectorize(psi)
  Y    <- psi2(eval_theta)
  gam_basis <- gam(Y ~ s(eval_theta))
  psi <- function(theta) predict(gam_basis, newdata = data.frame(eval_theta = theta))
  psi
}

root_gam1 <- eeroot_mod(
  geex_list = myList,
  start     = 2,
  apprx_fun = gam_approx,
  apprx_options = list(eval_theta = seq(1, 5, by = .3))
)

# Compare to the truth
median(dt$Y) - root_gam1$root


# Still, the basis of the spline influences the result
root_gam2 <- eeroot_mod(
  geex_list = myList,
  start     = 2,
  apprx_fun = gam_approx,
  apprx_options = list(eval_theta = seq(1.5, 3.5, length.out = 20))
)

# Compare to the truth
median(dt$Y) - root_gam2$root

```

What happens when the $n$ increases from 100 to 10000?

```{r gam_approx_10000, echo = TRUE}
dt2 <- data.frame(Y = rnorm(n, mean = theta_tru, sd = sigma), id = 1:10000)
myList2 <- list(eeFUN = SB7_eefun, splitdt = split(dt2, f = dt2$id))

root_spline4 <- eeroot_mod(
  geex_list = myList2,
  start     = 2,
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(0, 5, by = .1))
)

median(dt2$Y) - root_spline4$root

root_gam3 <- eeroot_mod(
  geex_list = myList2,
  start     = 2,
  apprx_fun = gam_approx,
  apprx_options = list(eval_theta = seq(0, 5, by = .1))
)

# Compare to the truth
median(dt$Y) - root_gam3$root
```

In order to compute $A_i$, we need to approximate $\psi_i$, so I'll make a similar modification to `compute_matrices`.

```{r compute_matrices_mod, echo = TRUE}
compute_matrices_mod <- function(geex_list,
                             theta,
                             numDeriv_options = list(method = 'Richardson'),
                             silent = TRUE,
                             apprx_fun     = NULL,
                             apprx_options = NULL,
                             ...){
  if(is.null(geex_list$ee_args)){
    ee_args <- NULL
  }

  with(geex_list, {

    # Create list of estimating eqn functions per unit
    psi_i <- lapply(splitdt, function(data_i){
      f <- eeFUN(data = data_i, ...)
      if(!is.null(apprx_fun)){
        f <- do.call(apprx_fun, args = append(list(psi = f), apprx_options))
      }
      f
    })

    # Compute the negative of the derivative matrix of estimating eqn functions
    # (the information matrix)
    A_i <- lapply(psi_i, function(ee){
      args <- append(list(fun = ee, x = theta), numDeriv_options)
      val  <- do.call(numDeriv::jacobian, args = append(args, ee_args))
      -val
    })
    A_i_array <- check_array(simplify2array(A_i))
    A   <- apply(A_i_array, 1:2, sum)

    # Compute outer product of observed estimating eqns
    B_i <- lapply(psi_i, function(ee) {
      ee_val <- do.call(ee, args = append(list(theta = theta), ee_args))
      ee_val %*% t(ee_val)
    })
    B   <- apply(check_array(simplify2array(B_i)), 1:2, sum)

    list(A = A, A_i = A_i, B = B, B_i = B_i)
  })
}
```

```{r matrices, echo = TRUE}
spline_matrices1 <- compute_matrices_mod(
  geex_list = myList,
  theta     = median(dt$Y),
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(0, 4, by = .5))
)

compute_sigma(A = spline_matrices1$A, B = spline_matrices1$B) 


gam_matrices1 <- compute_matrices_mod(
  geex_list = myList,
  theta     = median(dt$Y),
  apprx_fun = gam_approx,
  apprx_options = list(eval_theta = seq(0, 4, by = .3))
)

compute_sigma(A = gam_matrices1$A, B = gam_matrices1$B) 

# V(theta) from Stefanski and Boos
((0.5 * (1 -0.5))/((dnorm(median(dt2$Y), mean = mean(dt2$Y), sd = sd(dt2$Y)))^2) ) 
```

For the the quantiles in particular, Stefanski and Boos suggest directly approximating f(theta) by a kernel density.
Let's try that.

```{r dens_approx, echo = TRUE}
dens <- density(dt$Y)
ff <- splinefun(x = dens$x, y = dens$y)
density_apprx <- function(psi){
  function(theta) ff(theta)
}

density_matrices1 <- compute_matrices_mod(
  geex_list = myList,
  theta     = median(dt$Y),
  apprx_fun = density_apprx
)

compute_sigma(A = density_matrices1$A, B = density_matrices1$B) 

```

What would happen if instead of approximating $\psi$ for finding roots, we approximated $\psi_i$? I'm sure it would be slower, but if making same approximations for both situations (finding roots and derivatives of $A_i$) seems more principled plus the code would be modified in the same location in both `eeroot` and `compute_matrices`.


```{r eeroot_modified2, echo = TRUE, eval=TRUE}

# Put apprx_fun code in same place as compute_matrices
eeroot_mod2<- function(geex_list,
                   start         = NULL,
                   rootsolver    = rootSolve::multiroot,
                   root_options  = NULL,
                   apprx_fun     = NULL,
                   apprx_options = NULL,
                   ...){

  # Create estimating equation functions per group
  psi_i <- lapply(geex_list$splitdt, function(data_i){
      f <- geex_list$eeFUN(data = data_i, ...)
      if(!is.null(apprx_fun)){
        f <- do.call(apprx_fun, args = append(list(psi = f), apprx_options))
      }
      f
  })

  # Create psi function that sums over all ee funs
  psi <- function(theta){
    psii <- lapply(psi_i, function(f) {
      do.call(f, args = append(list(theta = theta), geex_list$ee_args))
    })
    apply(check_array(simplify2array(psii)), 1, sum)
  }
  # Find roots of psi
  rargs <- append(root_options, list(f = psi, start = start))
  do.call(rootsolver, args = rargs)
}
```

```{r, echo = TRUE}
# But notice that the basis of the spline matters too
root_spline5 <- eeroot_mod2(
  geex_list = myList,
  start     = 2,
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(-5, 5, by = 1))
)

# Compare to the truth
median(dt$Y) - root_spline5$root

root_gam5 <- eeroot_mod2(
  geex_list = myList,
  start     = 2,
  apprx_fun = gam_approx,
  apprx_options = list(eval_theta = seq(0, 5, by = .1))
)

# Compare to the truth
median(dt$Y) - root_gam5$root
```


```{r, echo = TRUE}
# But notice that the basis of the spline matters too
root_spline6 <- eeroot_mod2(
  geex_list = myList2,
  start     = 2,
  apprx_fun = spline_approx,
  apprx_options = list(eval_theta = seq(-5, 5, by = 1))
)

# Compare to the truth
median(dt$Y) - root_spline6$root

root_gam6 <- eeroot_mod(
  geex_list = myList2,
  start     = 2,
  apprx_fun = gam_approx,
  apprx_options = list(eval_theta = seq(0, 5, by = .1))
)

# Compare to the truth
median(dt$Y) - root_gam6$root
```

Not really.

Now try to approximate a multidimensional $\psi$ function.
```{r SB7_eefun2, echo = TRUE}
SB7_eefun2 <- function(data){
  function(theta){
    with(data,
    c(0.25  - (Y <= theta[1]),
      0.5   - (Y <= theta[2]),
      0.75  - (Y <= theta[3]))
    )
  }
}
```

The code next is work in progress. No good, so far.

```{r multi_psi, echo = TRUE, eval=FALSE}
gam_approx_multi <- function(psi, eval_theta1, eval_theta2, eval_theta3){
  ### Use splinefun ####
  # psi2 <- Vectorize(psi)
  Y <- matrix(NA, nrow = length(eval_theta1), ncol = 3)
  for(i in 1:length(eval_theta1)){
      Y[i, ]  <- psi(c(eval_theta1[i], eval_theta2[i], eval_theta3[i]))
  }

  gam_data <- data.frame(
    Y1 = Y[, 1],
    Y2 = Y[, 2],
    Y3 = Y[, 3],
    x1 = eval_theta1,
    x2 = eval_theta2,
    x3 = eval_theta3
  )

  gam_basis <- gam(list(Y1 ~ s(x1),
                        Y2 ~ s(x2),
                        Y3 ~ s(x3)),
                   family = mvn(d = 3),
                   data = gam_data)
  print(gam_basis)
  psi <- function(theta) {
    predict(gam_basis, newdata = data.frame(eval_theta1 = theta[1],
                                            eval_theta2 = theta[2],
                                            eval_theta3 = theta[3]))
  }
  psi
}

SB7_eefun2(dt[1, ])(c(1, 2, 3))

myList3 <- list(eeFUN = SB7_eefun2, splitdt = split(dt, f = dt$id))

root_gam1 <- eeroot_mod(
  geex_list = myList3,
  start     = c(1, 2, 3),
  apprx_fun = gam_approx_multi,
  apprx_options = list(eval_theta1 = seq(-5, 5, by = .1),
                       eval_theta2 = seq(-5, 5, by = .1),
                       eval_theta3 = seq(-5, 5, by = .1))
)

quantile(dt$Y, probs = c(.25, .5, .75))


```


```{r SB7_run, echo = TRUE, eval=FALSE}
estimates <- estimate_equations(eeFUN = SB7_eefun, 
                                data  = dt, units = 'id', 
                                findroots = FALSE,
                                roots = c(2))
```

```{r SB7_clsform, echo = TRUE}
theta_cls <- c(quantile(dt$Y, 0.5), quantile(dt$Y, 0.65))

```

```{r SB7_results, echo = FALSE, results = 'asis', eval=FALSE}
results <- list(geex = estimates, cls = list(parameters = theta_cls, vcov = Sigma_cls))
results
# print_results(results, 'Example 7', 'Example 7')
```
